<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale= 1.0"/>
  <title>SVG Overlay Tool</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; }
    .main-container { display: flex; gap: 2rem; align-items: flex-start; }
    #canvas { position: relative; width: 640px; height: 480px; border: 1px solid #ccc; margin-top: 1rem; flex-shrink: 0; }
    .svg-wrapper { position: absolute; box-sizing: border-box; /* cursor: pointer; */ border: 2px dashed #888; pointer-events: none; }
    .svg-wrapper.selected { outline: 2px solid #007bff; }
    .svg-wrapper svg { display: block; max-width: 100%; height: auto; }
    .controls { margin-top: 1rem; min-width: 300px; }
    .control-group { margin-bottom: 1rem; padding: 0.5rem; border-radius: 4px; }
    .control-group.selected { background-color: #f8f9fa; }
    .control-group h4 { margin-top: 0; }
    input[type="range"] { width: 300px; }
    .color-controls { display: flex; gap: 1rem; margin-bottom: 0.5rem; }
    .color-control { display: flex; align-items: center; gap: 0.5rem; }
    .color-control input[type="color"] { width: 40px; height: 30px; }
    .keyboard-hint { 
      margin-top: 1rem; 
      padding: 0.5rem; 
      background-color: #e9ecef; 
      border-radius: 4px; 
      font-size: 0.9rem; 
    }
    .save-controls {
      margin-top: 1rem;
      padding: 1rem;
      background-color: #f8f9fa;
      border-radius: 4px;
      border: 1px solid #dee2e6;
    }
    .save-controls button {
      margin-right: 0.5rem;
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .save-controls button.save {
      background-color: #28a745;
      color: white;
    }
    .save-controls button.clear {
      background-color: #dc3545;
      color: white;
    }
    .save-controls button:hover {
      opacity: 0.8;
    }
    .attribute-display {
      margin-top: 1rem;
      padding: 1rem;
      background-color: #f8f9fa;
      border-radius: 4px;
      border: 1px solid #dee2e6;
      font-family: monospace;
      font-size: 0.8rem;
    }
    .attribute-display h3 {
      margin-top: 0;
      margin-bottom: 0.5rem;
      color: #495057;
      font-size: 1rem;
    }
    .attribute-item {
      margin-bottom: 0.25rem;
      padding: 0.1rem 0;
      border-bottom: 1px solid #e9ecef;
    }
    .attribute-label {
      font-weight: bold;
      color: #495057;
      display: inline-block;
      min-width: 120px;
    }
    .attribute-value {
      color: #6c757d;
    }
  </style>
</head>
<body>
  <h2>SVG Overlay Tool</h2>
  <input type="file" id="fileInput" multiple accept=".svg"/>
  <div class="main-container">
    <div id="canvas"></div>
    <div id="controls" class="controls">
      <div class="control-group">
        <h3>Global Controls</h3>
        <label>Global Scale: <input type="range" id="globalScale" min="0.1" max="5" value="1" step="0.01"> <span id="globalScaleValue">1</span></label>
      </div>
      <div id="individualControls"></div>
    </div>
  </div>
  <div class="save-controls">
    <button class="save" onclick="saveState()">Save State</button>
    <button class="clear" onclick="clearState()">Clear Saved State</button>
    <span id="saveStatus"></span>
  </div>
  
  <div id="attributeDisplay" class="attribute-display" style="display: none;">
    <h3>Selected Image Attributes</h3>
    <div id="attributeContent"></div>
  </div>
  
  <div class="keyboard-hint">
    <strong>Keyboard Controls:</strong> Click on an image to select it, then use W/S keys for vertical movement, A/D keys for horizontal movement, and Left/Right arrow keys for scaling.
  </div>

  <script>
    const fileInput = document.getElementById('fileInput');
    const canvas = document.getElementById('canvas');
    const controls = document.getElementById('controls');
    const individualControls = document.getElementById('individualControls');
    const saveStatus = document.getElementById('saveStatus');
    const globalScaleSlider = document.getElementById('globalScale');
    const globalScaleValue = document.getElementById('globalScaleValue');
    const attributeDisplay = document.getElementById('attributeDisplay');
    const attributeContent = document.getElementById('attributeContent');
    
    let selectedWrapper = null;
    let selectedGroup = null;
    let selectedSliders = {};
    let loadedFiles = [];
    let globalScale = 1;

    // Save state to localStorage
    function saveState() {
      const state = {
        globalScale: globalScale,
        files: loadedFiles.map(file => ({
          name: file.name,
          content: file.content,
          minY: file.minY || 0,
          minX: file.minX || 0,
          scale: file.scale || 1,
          color: file.color || '#FF6B6B'
        }))
      };
      
      try {
        localStorage.setItem('svgOverlayState', JSON.stringify(state));
        saveStatus.textContent = 'State saved successfully!';
        saveStatus.style.color = '#28a745';
        setTimeout(() => {
          saveStatus.textContent = '';
        }, 2000);
      } catch (error) {
        saveStatus.textContent = 'Error saving state: ' + error.message;
        saveStatus.style.color = '#dc3545';
      }
    }

    // Clear saved state
    function clearState() {
      localStorage.removeItem('svgOverlayState');
      saveStatus.textContent = 'Saved state cleared!';
      saveStatus.style.color = '#dc3545';
      setTimeout(() => {
        saveStatus.textContent = '';
      }, 2000);
    }

    // Load state from localStorage
    async function loadState() {
      try {
        const savedState = localStorage.getItem('svgOverlayState');
        if (savedState) {
          const state = JSON.parse(savedState);
          
          // Restore global scale
          if (state.globalScale !== undefined) {
            globalScale = state.globalScale;
            globalScaleSlider.value = globalScale;
            globalScaleValue.textContent = globalScale.toFixed(2);
          }
          
          if (state.files && state.files.length > 0) {
            // Create File objects from saved data
            const files = state.files.map(fileData => {
              const blob = new Blob([fileData.content], { type: 'image/svg+xml' });
              const file = new File([blob], fileData.name, { type: 'image/svg+xml' });
              file.savedState = {
                minY: fileData.minY,
                minX: fileData.minX,
                scale: fileData.scale,
                color: fileData.color
              };
              return file;
            });
            
            // Simulate file input change with saved files
            const event = { target: { files: files } };
            await handleFiles(event);
            saveStatus.textContent = 'Previous state loaded!';
            saveStatus.style.color = '#007bff';
            setTimeout(() => {
              saveStatus.textContent = '';
            }, 2000);
          }
        }
      } catch (error) {
        console.error('Error loading state:', error);
        saveStatus.textContent = 'Error loading saved state';
        saveStatus.style.color = '#dc3545';
      }
    }

    // Handle file processing
    async function handleFiles(event) {
      canvas.innerHTML = '';
      individualControls.innerHTML = '';
      loadedFiles = [];
      attributeDisplay.style.display = 'none';
      selectedWrapper = null;
      selectedGroup = null;
      selectedSliders = {};
      const files = [...event.target.files];

      for (const [index, file] of files.entries()) {
        const text = await file.text();
        const wrapper = document.createElement('div');
        wrapper.className = 'svg-wrapper';
        wrapper.innerHTML = text;

        // Get the SVG element
        const svg = wrapper.querySelector('svg');
        if (!svg) continue;

        // Extract or set the original viewBox
        let originalViewBox = svg.getAttribute('viewBox');
        let [minX, minY, vbWidth, vbHeight] = [0, 0, 300, 300];
        if (originalViewBox) {
          [minX, minY, vbWidth, vbHeight] = originalViewBox.split(/\s+|,/).map(Number);
        } else {
          // If no viewBox, try to use width/height attributes
          vbWidth = parseFloat(svg.getAttribute('width')) || 300;
          vbHeight = parseFloat(svg.getAttribute('height')) || 300;
          svg.setAttribute('viewBox', `0 0 ${vbWidth} ${vbHeight}`);
        }
        // Store the base viewBox for this SVG
        svg._baseViewBox = { minX, minY, vbWidth, vbHeight };

        // Get saved state or use defaults
        const savedState = file.savedState || {};
        // The sliders now control minY (top), minX (left), and scale (zoom)
        const baseMinY = savedState.minY !== undefined ? savedState.minY : minY;
        const baseMinX = savedState.minX !== undefined ? savedState.minX : minX;
        const scale = savedState.scale !== undefined ? savedState.scale : 1;
        const color = savedState.color || getContrastingColor(index);

        // Set initial viewBox
        function setViewBox(minX, minY, scale) {
          const width = svg._baseViewBox.vbWidth / scale;
          const height = svg._baseViewBox.vbHeight / scale;
          svg.setAttribute('viewBox', `${minX} ${minY} ${width} ${height}`);
        }
        setViewBox(baseMinX, baseMinY, scale);

        // Ensure SVG is visible and properly sized
        svg.style.display = 'block';
        svg.setAttribute('width', svg._baseViewBox.vbWidth);
        svg.setAttribute('height', svg._baseViewBox.vbHeight);

        canvas.appendChild(wrapper);

        const group = document.createElement('div');
        group.className = 'control-group';
        group.innerHTML = `<h4 style="cursor: pointer; user-select: none;">${file.name}</h4>`;

        // Create color controls
        const colorControls = document.createElement('div');
        colorControls.className = 'color-controls';
        const colorControl = document.createElement('div');
        colorControl.className = 'color-control';
        colorControl.innerHTML = `
          <label>Color:</label>
          <input type="color" id="color-${index}" value="${color}">
        `;
        const colorInput = colorControl.querySelector('input');
        const applyColor = (color) => {
          const allElements = svg.querySelectorAll('*');
          allElements.forEach(el => {
            if ([
              'path', 'circle', 'rect', 'ellipse', 'line', 'polyline', 'polygon', 'text'
            ].includes(el.tagName.toLowerCase())) {
              el.setAttribute('stroke', color);
              el.setAttribute('fill', color);
              if (!el.getAttribute('stroke-width')) {
                el.setAttribute('stroke-width', '1');
              }
            }
          });
        };
        applyColor(color);
        colorInput.addEventListener('input', () => {
          applyColor(colorInput.value);
          if (selectedWrapper === wrapper) {
            updateAttributeDisplay();
          }
        });
        colorControls.appendChild(colorControl);
        group.appendChild(colorControls);

        // Create controls for minY (top), minX (left), and scale
        const controlConfigs = [
          { name: 'minY', label: 'top', min: minY - 200, max: minY + 200, value: baseMinY, unit: 'px' },
          { name: 'minX', label: 'left', min: minX - 200, max: minX + 200, value: baseMinX, unit: 'px' },
          { name: 'scale', label: 'scale', min: 0.1, max: 10, value: scale, step: 0.001, unit: '' }
        ];
        const sliders = {};
        controlConfigs.forEach(control => {
          const label = document.createElement('label');
          label.textContent = `${control.label}: `;
          const slider = document.createElement('input');
          slider.type = 'range';
          slider.min = control.min;
          slider.max = control.max;
          slider.value = control.value;
          if (control.step) slider.step = control.step;
          slider.addEventListener('input', () => {
            const minXVal = parseFloat(sliders.minX?.value ?? baseMinX);
            const minYVal = parseFloat(sliders.minY?.value ?? baseMinY);
            const scaleVal = parseFloat(sliders.scale?.value ?? scale);
            setViewBox(minXVal, minYVal, scaleVal);
            const displayValue = control.unit === 'px' ? parseFloat(slider.value).toFixed(2) : parseFloat(slider.value).toFixed(3);
            valueSpan.textContent = `${displayValue}${control.unit}`;
            if (selectedWrapper === wrapper) {
              updateAttributeDisplay();
            }
          });
          const valueSpan = document.createElement('span');
          const displayValue = control.unit === 'px' ? control.value.toFixed(2) : control.value.toFixed(3);
          valueSpan.textContent = `${displayValue}${control.unit}`;
          label.appendChild(slider);
          label.appendChild(valueSpan);
          group.appendChild(label);
          group.appendChild(document.createElement('br'));
          slider.setAttribute('data-control', control.name);
          sliders[control.name] = slider;
        });
        wrapper.sliders = sliders;
        wrapper.controlGroup = group;
        wrapper.fileName = file.name;
        wrapper.svg = svg;
        // Function to select this wrapper
        const selectWrapper = () => {
          if (selectedWrapper) {
            selectedWrapper.classList.remove('selected');
            selectedGroup.classList.remove('selected');
          }
          selectedWrapper = wrapper;
          selectedGroup = group;
          selectedSliders = sliders;
          wrapper.classList.add('selected');
          group.classList.add('selected');
          updateAttributeDisplay();
        };
        // Make the entire control group selectable on pointer down
        group.addEventListener('pointerdown', selectWrapper);
        individualControls.appendChild(group);
        // Store file data for saving
        loadedFiles.push({
          name: file.name,
          content: text,
          minY: baseMinY,
          minX: baseMinX,
          scale: scale,
          color: color
        });
      }
    }

    // Get contrasting color for different images
    function getContrastingColor(index) {
      const contrastingColors = [
        '#FF6B6B', // Red
        '#4ECDC4', // Teal
        '#1976D2', // Blue
        '#96CEB4', // Green
        '#FFEAA7', // Yellow
        '#DDA0DD', // Plum
        '#98D8C8', // Mint
        '#F7DC6F', // Gold
        '#BB8FCE', // Purple
        '#85C1E9'  // Light Blue
      ];
      return contrastingColors[index % contrastingColors.length];
    }

    fileInput.addEventListener('change', handleFiles);

    // Keyboard controls
    document.addEventListener('keydown', (event) => {
      if (!selectedWrapper || !selectedSliders) return;
      const step = event.shiftKey ? 10 : 1;
      switch(event.key.toLowerCase()) {
        case 'w':
          event.preventDefault();
          const minYSlider = selectedSliders.minY;
          if (minYSlider) {
            const newValue = Math.max(parseFloat(minYSlider.min), parseFloat(minYSlider.value) - step);
            minYSlider.value = newValue;
            minYSlider.dispatchEvent(new Event('input'));
          }
          break;
        case 's':
          event.preventDefault();
          if (selectedSliders.minY) {
            const newValue = Math.min(parseFloat(selectedSliders.minY.max), parseFloat(selectedSliders.minY.value) + step);
            selectedSliders.minY.value = newValue;
            selectedSliders.minY.dispatchEvent(new Event('input'));
          }
          break;
        case 'a':
          event.preventDefault();
          const minXSlider = selectedSliders.minX;
          if (minXSlider) {
            const newValue = Math.max(parseFloat(minXSlider.min), parseFloat(minXSlider.value) - step);
            minXSlider.value = newValue;
            minXSlider.dispatchEvent(new Event('input'));
          }
          break;
        case 'd':
          event.preventDefault();
          if (selectedSliders.minX) {
            const newValue = Math.min(parseFloat(selectedSliders.minX.max), parseFloat(selectedSliders.minX.value) + step);
            selectedSliders.minX.value = newValue;
            selectedSliders.minX.dispatchEvent(new Event('input'));
          }
          break;
        case 'arrowleft':
          event.preventDefault();
          const scaleSlider = selectedSliders.scale;
          if (scaleSlider) {
            const stepSize = event.shiftKey ? 0.1 : 0.01;
            const newValue = Math.max(parseFloat(scaleSlider.min), parseFloat(scaleSlider.value) - stepSize);
            scaleSlider.value = newValue;
            scaleSlider.dispatchEvent(new Event('input'));
          }
          break;
        case 'arrowright':
          event.preventDefault();
          if (selectedSliders.scale) {
            const stepSize = event.shiftKey ? 0.1 : 0.01;
            const newValue = Math.min(parseFloat(selectedSliders.scale.max), parseFloat(selectedSliders.scale.value) + stepSize);
            selectedSliders.scale.value = newValue;
            selectedSliders.scale.dispatchEvent(new Event('input'));
          }
          break;
      }
    });

    // Function to update attribute display
    function updateAttributeDisplay() {
      if (selectedWrapper && attributeDisplay.style.display !== 'none') {
        const svg = selectedWrapper.svg;
        const minX = parseFloat(selectedWrapper.sliders?.minX?.value || svg._baseViewBox.minX);
        const minY = parseFloat(selectedWrapper.sliders?.minY?.value || svg._baseViewBox.minY);
        const scale = parseFloat(selectedWrapper.sliders?.scale?.value || 1);
        const width = svg._baseViewBox.vbWidth / scale;
        const height = svg._baseViewBox.vbHeight / scale;
        const color = svg.querySelector('*')?.getAttribute('stroke') || 'N/A';
        attributeContent.innerHTML = `
          <div class="attribute-item">
            <span class="attribute-label">File name:</span>
            <span class="attribute-value">${selectedWrapper.fileName || 'Unknown'}</span>
          </div>
          <div class="attribute-item">
            <span class="attribute-label">viewBox:</span>
            <span class="attribute-value">${minX} ${minY} ${width} ${height}</span>
          </div>
          <div class="attribute-item">
            <span class="attribute-label">Scale:</span>
            <span class="attribute-value">${scale.toFixed(3)}</span>
          </div>
          <div class="attribute-item">
            <span class="attribute-label">Color:</span>
            <span class="attribute-value">${color}</span>
          </div>
          <div class="attribute-item">
            <span class="attribute-label">SVG size:</span>
            <span class="attribute-value">width: ${svg.getAttribute('width')}px, height: ${svg.getAttribute('height')}px</span>
          </div>
        `;
      }
    }

    // Auto-save state when values change
    function autoSave() {
      if (loadedFiles.length > 0) {
        // Update loadedFiles with current values
        const wrappers = canvas.querySelectorAll('.svg-wrapper');
        wrappers.forEach((wrapper, index) => {
          if (loadedFiles[index]) {
            const svg = wrapper.svg;
            const minX = parseFloat(wrapper.sliders?.minX?.value ?? svg._baseViewBox.minX);
            const minY = parseFloat(wrapper.sliders?.minY?.value ?? svg._baseViewBox.minY);
            const scale = parseFloat(wrapper.sliders?.scale?.value ?? 1);
            const colorInput = document.getElementById(`color-${index}`);
            const color = colorInput ? colorInput.value : loadedFiles[index].color;
            loadedFiles[index] = {
              ...loadedFiles[index],
              minX,
              minY,
              scale,
              color
            };
          }
        });
        // Save to localStorage
        const state = {
          globalScale: globalScale,
          files: loadedFiles
        };
        localStorage.setItem('svgOverlayState', JSON.stringify(state));
      }
    }

    // Global scale event listener
    globalScaleSlider.addEventListener('input', () => {
      const newGlobalScale = parseFloat(globalScaleSlider.value);
      const scaleRatio = newGlobalScale / globalScale;
      globalScale = newGlobalScale;
      globalScaleValue.textContent = globalScale.toFixed(2);
      
      // Update all wrappers with new global scale
      const wrappers = canvas.querySelectorAll('.svg-wrapper');
      wrappers.forEach(wrapper => {
        const svg = wrapper.svg;
        const scaleSlider = wrapper.sliders?.scale;
        if (scaleSlider) {
          const individualScale = parseFloat(scaleSlider.value);
          const currentMinX = parseFloat(wrapper.sliders?.minX?.value || svg._baseViewBox.minX);
          const currentMinY = parseFloat(wrapper.sliders?.minY?.value || svg._baseViewBox.minY);
          const newMinX = currentMinX * scaleRatio;
          const newMinY = currentMinY * scaleRatio;
          setViewBox(newMinX, newMinY, individualScale * globalScale);
          
          // Update the slider values to reflect the new positions
          if (wrapper.sliders.minX) {
            wrapper.sliders.minX.value = newMinX;
            wrapper.sliders.minX.nextElementSibling.textContent = `${newMinX.toFixed(2)}px`;
          }
          if (wrapper.sliders.minY) {
            wrapper.sliders.minY.value = newMinY;
            wrapper.sliders.minY.nextElementSibling.textContent = `${newMinY.toFixed(2)}px`;
          }
        }
        
        // Update attribute display if a wrapper is selected
        if (selectedWrapper) {
          updateAttributeDisplay();
        }
      });
    });

    // Add auto-save listeners
    document.addEventListener('input', autoSave);
    document.addEventListener('change', autoSave);

    // Load saved state on page load
    window.addEventListener('load', loadState);
  </script>
</body>
</html>
