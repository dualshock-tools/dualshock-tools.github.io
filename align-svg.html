<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale= 1.0"/>
  <title>SVG Overlay Tool</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; }
    .main-container { display: flex; gap: 2rem; align-items: flex-start; }
    #canvas { position: relative; width: 640px; height: 480px; border: 1px solid #ccc; margin-top: 1rem; flex-shrink: 0; }
    .svg-wrapper { position: absolute; box-sizing: border-box; cursor: pointer; }
    .svg-wrapper.selected { outline: 2px solid #007bff; }
    .svg-wrapper svg { display: block; max-width: 100%; height: auto; }
    .controls { margin-top: 1rem; min-width: 300px; }
    .control-group { margin-bottom: 1rem; }
    .control-group.selected { background-color: #f8f9fa; padding: 0.5rem; border-radius: 4px; }
    input[type="range"] { width: 300px; }
    .color-controls { display: flex; gap: 1rem; margin-bottom: 0.5rem; }
    .color-control { display: flex; align-items: center; gap: 0.5rem; }
    .color-control input[type="color"] { width: 40px; height: 30px; }
    .keyboard-hint { 
      margin-top: 1rem; 
      padding: 0.5rem; 
      background-color: #e9ecef; 
      border-radius: 4px; 
      font-size: 0.9rem; 
    }
    .save-controls {
      margin-top: 1rem;
      padding: 1rem;
      background-color: #f8f9fa;
      border-radius: 4px;
      border: 1px solid #dee2e6;
    }
    .save-controls button {
      margin-right: 0.5rem;
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .save-controls button.save {
      background-color: #28a745;
      color: white;
    }
    .save-controls button.clear {
      background-color: #dc3545;
      color: white;
    }
    .save-controls button:hover {
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <h2>SVG Overlay Tool</h2>
  <input type="file" id="fileInput" multiple accept=".svg"/>
  <div class="main-container">
    <div id="canvas"></div>
    <div id="controls" class="controls">
      <div class="control-group">
        <h3>Global Controls</h3>
        <label>Global Scale: <input type="range" id="globalScale" min="0.1" max="5" value="1" step="0.01"> <span id="globalScaleValue">1</span></label>
      </div>
      <div id="individualControls"></div>
    </div>
  </div>
  <div class="save-controls">
    <button class="save" onclick="saveState()">Save State</button>
    <button class="clear" onclick="clearState()">Clear Saved State</button>
    <span id="saveStatus"></span>
  </div>
  <div class="keyboard-hint">
    <strong>Keyboard Controls:</strong> Click on an image to select it, then use W/S keys for vertical movement, A/D keys for horizontal movement, and Left/Right arrow keys for scaling.
  </div>

  <script>
    const fileInput = document.getElementById('fileInput');
    const canvas = document.getElementById('canvas');
    const controls = document.getElementById('controls');
    const individualControls = document.getElementById('individualControls');
    const saveStatus = document.getElementById('saveStatus');
    const globalScaleSlider = document.getElementById('globalScale');
    const globalScaleValue = document.getElementById('globalScaleValue');
    
    let selectedWrapper = null;
    let selectedGroup = null;
    let selectedSliders = {};
    let loadedFiles = [];
    let globalScale = 1;

    // Save state to localStorage
    function saveState() {
      const state = {
        globalScale: globalScale,
        files: loadedFiles.map(file => ({
          name: file.name,
          content: file.content,
          top: file.top || 0,
          left: file.left || 0,
          scale: file.scale || 1,
          color: file.color || '#FF6B6B'
        }))
      };
      
      try {
        localStorage.setItem('svgOverlayState', JSON.stringify(state));
        saveStatus.textContent = 'State saved successfully!';
        saveStatus.style.color = '#28a745';
        setTimeout(() => {
          saveStatus.textContent = '';
        }, 2000);
      } catch (error) {
        saveStatus.textContent = 'Error saving state: ' + error.message;
        saveStatus.style.color = '#dc3545';
      }
    }

    // Clear saved state
    function clearState() {
      localStorage.removeItem('svgOverlayState');
      saveStatus.textContent = 'Saved state cleared!';
      saveStatus.style.color = '#dc3545';
      setTimeout(() => {
        saveStatus.textContent = '';
      }, 2000);
    }

    // Load state from localStorage
    async function loadState() {
      try {
        const savedState = localStorage.getItem('svgOverlayState');
        if (savedState) {
          const state = JSON.parse(savedState);
          
          // Restore global scale
          if (state.globalScale !== undefined) {
            globalScale = state.globalScale;
            globalScaleSlider.value = globalScale;
            globalScaleValue.textContent = globalScale.toFixed(2);
          }
          
          if (state.files && state.files.length > 0) {
            // Create File objects from saved data
            const files = state.files.map(fileData => {
              const blob = new Blob([fileData.content], { type: 'image/svg+xml' });
              const file = new File([blob], fileData.name, { type: 'image/svg+xml' });
              file.savedState = {
                top: fileData.top,
                left: fileData.left,
                scale: fileData.scale,
                color: fileData.color
              };
              return file;
            });
            
            // Simulate file input change with saved files
            const event = { target: { files: files } };
            await handleFiles(event);
            saveStatus.textContent = 'Previous state loaded!';
            saveStatus.style.color = '#007bff';
            setTimeout(() => {
              saveStatus.textContent = '';
            }, 2000);
          }
        }
      } catch (error) {
        console.error('Error loading state:', error);
        saveStatus.textContent = 'Error loading saved state';
        saveStatus.style.color = '#dc3545';
      }
    }

    // Handle file processing
    async function handleFiles(event) {
      canvas.innerHTML = '';
      individualControls.innerHTML = '';
      loadedFiles = [];
      const files = [...event.target.files];

      for (const [index, file] of files.entries()) {
        const text = await file.text();
        const wrapper = document.createElement('div');
        wrapper.className = 'svg-wrapper';
        wrapper.innerHTML = text;
        
        // Get saved state or use defaults
        const savedState = file.savedState || {};
        const baseTop = savedState.top !== undefined ? savedState.top : 0;
        const baseLeft = savedState.left !== undefined ? savedState.left : 0;
        // The saved scale is the individual scale value
        const scale = savedState.scale !== undefined ? savedState.scale : 1;
        const color = savedState.color || getContrastingColor(index);
        
        // Apply global scale to base positions
        const top = baseTop * globalScale;
        const left = baseLeft * globalScale;
        
        wrapper.style.top = `${top}px`;
        wrapper.style.left = `${left}px`;
        wrapper.style.transform = `scale(${scale * globalScale}, ${scale * globalScale})`;
        wrapper.style.transformOrigin = 'top left';
        
        // Ensure SVG is visible and properly sized
        const svg = wrapper.querySelector('svg');
        if (svg) {
          if (!svg.getAttribute('width') && !svg.getAttribute('height')) {
            svg.setAttribute('width', '300');
            svg.setAttribute('height', '300');
          }
          svg.style.display = 'block';
        }
        
        canvas.appendChild(wrapper);

        const group = document.createElement('div');
        group.className = 'control-group';
        group.innerHTML = `<h4 style="cursor: pointer; user-select: none;">${file.name}</h4>`;

        // Create color controls
        const colorControls = document.createElement('div');
        colorControls.className = 'color-controls';
        
        // Single color control for both stroke and fill
        const colorControl = document.createElement('div');
        colorControl.className = 'color-control';
        colorControl.innerHTML = `
          <label>Color:</label>
          <input type="color" id="color-${index}" value="${color}">
        `;
        const colorInput = colorControl.querySelector('input');
        
        // Function to apply color to SVG elements
        const applyColor = (color) => {
          const svg = wrapper.querySelector('svg');
          if (svg) {
            const allElements = svg.querySelectorAll('*');
            allElements.forEach(el => {
              // Only apply to elements that can have stroke or fill
              if (['path', 'circle', 'rect', 'ellipse', 'line', 'polyline', 'polygon', 'text'].includes(el.tagName.toLowerCase())) {
                el.setAttribute('stroke', color);
                el.setAttribute('fill', color);
                // Also set stroke-width if not already set
                if (!el.getAttribute('stroke-width')) {
                  el.setAttribute('stroke-width', '1');
                }
              }
            });
          }
        };
        
        // Apply color immediately
        applyColor(color);
        
        colorInput.addEventListener('input', () => {
          applyColor(colorInput.value);
        });
        
        colorControls.appendChild(colorControl);
        group.appendChild(colorControls);

        // Create controls for top, left, and scale
        const controlConfigs = [
          { name: 'top', min: -200, max: 200, value: top, unit: 'px' },
          { name: 'left', min: -200, max: 200, value: left, unit: 'px' },
          { name: 'scale', min: 0.1, max: 10, value: scale, step: 0.001, unit: '' }
        ];

        const sliders = {};

        controlConfigs.forEach(control => {
          const label = document.createElement('label');
          label.textContent = `${control.name}: `;
          const slider = document.createElement('input');
          slider.type = 'range';
          slider.min = control.min;
          slider.max = control.max;
          slider.value = control.value;
          if (control.step) slider.step = control.step;
          
          slider.addEventListener('input', () => {
            const value = parseFloat(slider.value);
            const displayValue = control.unit === 'px' ? value.toFixed(2) : value.toFixed(3);
            valueSpan.textContent = `${displayValue}${control.unit}`;
            
            if (control.name === 'top') {
              wrapper.style.top = `${value}px`;
            } else if (control.name === 'left') {
              wrapper.style.left = `${value}px`;
            } else if (control.name === 'scale') {
              wrapper.style.transform = `scale(${value * globalScale}, ${value * globalScale})`;
            }
          });
          
          const valueSpan = document.createElement('span');
          const displayValue = control.unit === 'px' ? control.value.toFixed(2) : control.value.toFixed(3);
          valueSpan.textContent = `${displayValue}${control.unit}`;
          label.appendChild(slider);
          label.appendChild(valueSpan);
          group.appendChild(label);
          group.appendChild(document.createElement('br'));
          
          // Add data attribute to identify sliders
          slider.setAttribute('data-control', control.name);
          sliders[control.name] = slider;
        });

        // Store sliders for this wrapper
        wrapper.sliders = sliders;
        wrapper.controlGroup = group;

        // Function to select this wrapper
        const selectWrapper = () => {
          // Remove previous selection
          if (selectedWrapper) {
            selectedWrapper.classList.remove('selected');
            selectedGroup.classList.remove('selected');
          }
          
          // Select this wrapper
          selectedWrapper = wrapper;
          selectedGroup = group;
          selectedSliders = sliders;
          
          wrapper.classList.add('selected');
          group.classList.add('selected');
        };

        // Add click handler to select this wrapper
        wrapper.addEventListener('click', selectWrapper);
        
        // Add click handler to the filename to select this wrapper
        const filename = group.querySelector('h4');
        filename.addEventListener('click', selectWrapper);

        individualControls.appendChild(group);

        // Store file data for saving
        loadedFiles.push({
          name: file.name,
          content: text,
          top: top,
          left: left,
          scale: scale,
          color: color
        });
      }
    }

    // Get contrasting color for different images
    function getContrastingColor(index) {
      const contrastingColors = [
        '#FF6B6B', // Red
        '#4ECDC4', // Teal
        '#45B7D1', // Blue
        '#96CEB4', // Green
        '#FFEAA7', // Yellow
        '#DDA0DD', // Plum
        '#98D8C8', // Mint
        '#F7DC6F', // Gold
        '#BB8FCE', // Purple
        '#85C1E9'  // Light Blue
      ];
      return contrastingColors[index % contrastingColors.length];
    }

    fileInput.addEventListener('change', handleFiles);

    // Keyboard controls
    document.addEventListener('keydown', (event) => {
      if (!selectedWrapper || !selectedSliders) return;
      
      const step = event.shiftKey ? 10 : 1; // Shift key for larger steps
      
      switch(event.key.toLowerCase()) {
        case 'w':
          event.preventDefault();
          const topSlider = selectedSliders.top;
          if (topSlider) {
            const newValue = Math.max(parseFloat(topSlider.min), parseFloat(topSlider.value) - step);
            topSlider.value = newValue;
            topSlider.dispatchEvent(new Event('input'));
          }
          break;
        case 's':
          event.preventDefault();
          if (selectedSliders.top) {
            const newValue = Math.min(parseFloat(selectedSliders.top.max), parseFloat(selectedSliders.top.value) + step);
            selectedSliders.top.value = newValue;
            selectedSliders.top.dispatchEvent(new Event('input'));
          }
          break;
        case 'a':
          event.preventDefault();
          const leftSlider = selectedSliders.left;
          if (leftSlider) {
            const newValue = Math.max(parseFloat(leftSlider.min), parseFloat(leftSlider.value) - step);
            leftSlider.value = newValue;
            leftSlider.dispatchEvent(new Event('input'));
          }
          break;
        case 'd':
          event.preventDefault();
          if (selectedSliders.left) {
            const newValue = Math.min(parseFloat(selectedSliders.left.max), parseFloat(selectedSliders.left.value) + step);
            selectedSliders.left.value = newValue;
            selectedSliders.left.dispatchEvent(new Event('input'));
          }
          break;
        case 'arrowleft':
          event.preventDefault();
          const scaleSlider = selectedSliders.scale;
          if (scaleSlider) {
            const stepSize = event.shiftKey ? 0.1 : 0.01;
            const newValue = Math.max(parseFloat(scaleSlider.min), parseFloat(scaleSlider.value) - stepSize);
            scaleSlider.value = newValue;
            scaleSlider.dispatchEvent(new Event('input'));
          }
          break;
        case 'arrowright':
          event.preventDefault();
          if (selectedSliders.scale) {
            const stepSize = event.shiftKey ? 0.1 : 0.01;
            const newValue = Math.min(parseFloat(selectedSliders.scale.max), parseFloat(selectedSliders.scale.value) + stepSize);
            selectedSliders.scale.value = newValue;
            selectedSliders.scale.dispatchEvent(new Event('input'));
          }
          break;
      }
    });

    // Auto-save state when values change
    function autoSave() {
      if (loadedFiles.length > 0) {
        // Update loadedFiles with current values
        const wrappers = canvas.querySelectorAll('.svg-wrapper');
        wrappers.forEach((wrapper, index) => {
          if (loadedFiles[index]) {
            // Save the base positions (not adjusted by global scale)
            const currentTop = parseFloat(wrapper.style.top) || 0;
            const currentLeft = parseFloat(wrapper.style.left) || 0;
            const baseTop = currentTop / globalScale;
            const baseLeft = currentLeft / globalScale;
            
            // Get the individual scale value from the slider, not the combined transform
            const scaleSlider = wrapper.sliders?.scale;
            const scale = scaleSlider ? parseFloat(scaleSlider.value) : 1;
            const colorInput = document.getElementById(`color-${index}`);
            const color = colorInput ? colorInput.value : loadedFiles[index].color;
            
            loadedFiles[index] = {
              ...loadedFiles[index],
              top: baseTop,
              left: baseLeft,
              scale,
              color
            };
          }
        });
        
        // Save to localStorage
        const state = {
          globalScale: globalScale,
          files: loadedFiles
        };
        localStorage.setItem('svgOverlayState', JSON.stringify(state));
      }
    }

    // Global scale event listener
    globalScaleSlider.addEventListener('input', () => {
      const newGlobalScale = parseFloat(globalScaleSlider.value);
      const scaleRatio = newGlobalScale / globalScale;
      globalScale = newGlobalScale;
      globalScaleValue.textContent = globalScale.toFixed(2);
      
      // Update all wrappers with new global scale
      const wrappers = canvas.querySelectorAll('.svg-wrapper');
      wrappers.forEach(wrapper => {
        const scaleSlider = wrapper.sliders?.scale;
        if (scaleSlider) {
          const individualScale = parseFloat(scaleSlider.value);
          wrapper.style.transform = `scale(${individualScale * globalScale}, ${individualScale * globalScale})`;
          
          // Adjust position to compensate for scaling
          const currentTop = parseFloat(wrapper.style.top) || 0;
          const currentLeft = parseFloat(wrapper.style.left) || 0;
          
          // Calculate the new position that maintains the visual position
          const newTop = currentTop * scaleRatio;
          const newLeft = currentLeft * scaleRatio;
          
          wrapper.style.top = `${newTop}px`;
          wrapper.style.left = `${newLeft}px`;
          
          // Update the slider values to reflect the new positions
          if (wrapper.sliders.top) {
            wrapper.sliders.top.value = newTop;
            wrapper.sliders.top.nextElementSibling.textContent = `${newTop.toFixed(2)}px`;
          }
          if (wrapper.sliders.left) {
            wrapper.sliders.left.value = newLeft;
            wrapper.sliders.left.nextElementSibling.textContent = `${newLeft.toFixed(2)}px`;
          }
        }
      });
    });

    // Add auto-save listeners
    document.addEventListener('input', autoSave);
    document.addEventListener('change', autoSave);

    // Load saved state on page load
    window.addEventListener('load', loadState);
  </script>
</body>
</html>
