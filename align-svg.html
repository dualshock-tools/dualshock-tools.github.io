<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale= 1.0"/>
  <title>SVG Overlay Tool</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; }
    .main-container { display: flex; gap: 2rem; align-items: flex-start; }
    #canvas { position: relative; width: 640px; height: 480px; border: 1px solid #ccc; margin-top: 1rem; flex-shrink: 0; }
    .svg-wrapper {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      /* cursor: pointer; */
      border: 2px dashed #888;
      pointer-events: none;
    }
    .svg-wrapper.selected { outline: 2px solid #007bff; }
    .svg-wrapper svg {
      display: block;
      width: 100%;
      height: 100%;
    }
    .controls { margin-top: 1rem; min-width: 300px; }
    .control-group { margin-bottom: 1rem; padding: 0.5rem; border-radius: 4px; }
    .control-group.selected { background-color: #f8f9fa; }
    .control-group h4 { margin-top: 0; }
    input[type="range"] { width: 300px; }
    .color-controls { display: flex; gap: 1rem; margin-bottom: 0.5rem; }
    .color-control { display: flex; align-items: center; gap: 0.5rem; }
    .color-control input[type="color"] { width: 40px; height: 30px; }
    .keyboard-hint { 
      margin-top: 1rem; 
      padding: 0.5rem; 
      background-color: #e9ecef; 
      border-radius: 4px; 
      font-size: 0.9rem; 
    }
    .save-controls {
      margin-top: 1rem;
      padding: 1rem;
      background-color: #f8f9fa;
      border-radius: 4px;
      border: 1px solid #dee2e6;
    }
    .save-controls button {
      margin-right: 0.5rem;
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .save-controls button.save {
      background-color: #28a745;
      color: white;
    }
    .save-controls button.clear {
      background-color: #dc3545;
      color: white;
    }
    .save-controls button:hover {
      opacity: 0.8;
    }
    .attribute-display {
      margin-top: 1rem;
      padding: 1rem;
      background-color: #f8f9fa;
      border-radius: 4px;
      border: 1px solid #dee2e6;
      font-family: monospace;
      font-size: 0.8rem;
    }
    .attribute-display h3 {
      margin-top: 0;
      margin-bottom: 0.5rem;
      color: #495057;
      font-size: 1rem;
    }
    .attribute-item {
      margin-bottom: 0.25rem;
      padding: 0.1rem 0;
      border-bottom: 1px solid #e9ecef;
    }
    .attribute-label {
      font-weight: bold;
      color: #495057;
      display: inline-block;
      min-width: 120px;
    }
    .attribute-value {
      color: #6c757d;
    }
  </style>
</head>
<body>
  <h2>SVG Overlay Tool</h2>
  <div id="canvasSizeControls" style="margin-bottom: 1rem;">
    <label style="margin-right:1em;">Width:
      <input type="range" id="canvasWidthSlider" min="100" max="1920" value="640" step="1">
      <span id="canvasWidthValue">640</span>px
    </label>
    <label>Height:
      <input type="range" id="canvasHeightSlider" min="100" max="1080" value="480" step="1">
      <span id="canvasHeightValue">480</span>px
    </label>
  </div>
  <input type="file" id="fileInput" multiple accept=".svg"/>
  <div class="main-container">
    <div id="canvas"></div>
    <div id="controls" class="controls">
      <div id="individualControls"></div>
    </div>
  </div>
  <div class="save-controls">
    <button class="save" onclick="saveState()">Save State</button>
    <button class="clear" onclick="clearState()">Clear Saved State</button>
    <button class="preview" onclick="openPreviewModal()">Preview</button>
    <button class="combine" onclick="combineSVGs()">Combine</button>
    <span id="saveStatus"></span>
  </div>
  
  <div id="attributeDisplay" class="attribute-display" style="display: none;">
    <h3>Selected Image Attributes</h3>
    <div id="attributeContent"></div>
  </div>
  
  <div class="keyboard-hint">
    <strong>Keyboard Controls:</strong> Click on an image to select it, then use W/S keys for vertical movement, A/D keys for horizontal movement, and Left/Right arrow keys for scaling.
  </div>

  <!-- Modal for SVG preview -->
  <div id="previewModal" style="display:none; position:fixed; z-index:1000; left:0; top:0; width:100vw; height:100vh; background:rgba(0,0,0,0.7); align-items:center; justify-content:center;">
    <div style="position:relative; background:white; border-radius:8px; padding:1.5rem; max-width:90vw; max-height:90vh; overflow:auto; box-shadow:0 2px 16px rgba(0,0,0,0.3);">
      <button onclick="closePreviewModal()" style="position:absolute; top:0.5rem; right:0.5rem; background:#dc3545; color:white; border:none; border-radius:4px; padding:0.3rem 0.7rem; font-size:1.2rem; cursor:pointer;">&times;</button>
      <div id="previewSVGs" style="position:relative; width:500px; height:auto; background:#fff;"></div>
    </div>
  </div>

  <script>
    const fileInput = document.getElementById('fileInput');
    const canvas = document.getElementById('canvas');
    const controls = document.getElementById('controls');
    const individualControls = document.getElementById('individualControls');
    const saveStatus = document.getElementById('saveStatus');
    let selectedWrapper = null;
    let selectedGroup = null;
    let selectedSliders = {};
    let loadedFiles = [];
    let isLoading = false;

    // Canvas size controls
    const canvasWidthSlider = document.getElementById('canvasWidthSlider');
    const canvasHeightSlider = document.getElementById('canvasHeightSlider');
    const canvasWidthValue = document.getElementById('canvasWidthValue');
    const canvasHeightValue = document.getElementById('canvasHeightValue');
    function updateCanvasSize() {
      const w = canvasWidthSlider.value;
      const h = canvasHeightSlider.value;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      canvasWidthValue.textContent = w;
      canvasHeightValue.textContent = h;
      // Save canvas size to localStorage for persistence
      localStorage.setItem('svgOverlayCanvasSize', JSON.stringify({ width: w, height: h }));
    }
    canvasWidthSlider.addEventListener('input', updateCanvasSize);
    canvasHeightSlider.addEventListener('input', updateCanvasSize);
    // Set initial size
    updateCanvasSize();

    // Save state to localStorage
    function saveState() {
      const state = {
        files: loadedFiles.map(file => ({
          name: file.name,
          content: file.content,
          minYOffset: file.minYOffset || 0,
          minXOffset: file.minXOffset || 0,
          scale: file.scale || 1,
          color: file.color || '#FF6B6B'
        })),
        canvasSize: {
          width: canvasWidthSlider.value,
          height: canvasHeightSlider.value
        }
      };
      
      try {
        localStorage.setItem('svgOverlayState', JSON.stringify(state));
        saveStatus.textContent = 'State saved successfully!';
        saveStatus.style.color = '#28a745';
        setTimeout(() => {
          saveStatus.textContent = '';
        }, 2000);
      } catch (error) {
        saveStatus.textContent = 'Error saving state: ' + error.message;
        saveStatus.style.color = '#dc3545';
      }
    }

    // Clear saved state
    function clearState() {
      localStorage.removeItem('svgOverlayState');
      saveStatus.textContent = 'Saved state cleared!';
      saveStatus.style.color = '#dc3545';
      setTimeout(() => {
        saveStatus.textContent = '';
      }, 2000);
    }

    // Load state from localStorage
    async function loadState() {
      isLoading = true;
      try {
        // Load canvas size first
        let canvasSize = null;
        // Try to get from svgOverlayState (new format)
        const savedState = localStorage.getItem('svgOverlayState');
        if (savedState) {
          const state = JSON.parse(savedState);
          if (state.canvasSize) {
            canvasSize = state.canvasSize;
          }
        }
        // Fallback: try legacy key
        if (!canvasSize) {
          const legacySize = localStorage.getItem('svgOverlayCanvasSize');
          if (legacySize) {
            canvasSize = JSON.parse(legacySize);
          }
        }
        if (canvasSize) {
          canvasWidthSlider.value = canvasSize.width;
          canvasHeightSlider.value = canvasSize.height;
          updateCanvasSize();
        }
        if (savedState) {
          const state = JSON.parse(savedState);
          
          if (state.files && state.files.length > 0) {
            // Pass plain objects with content and savedState
            const files = state.files.map(fileData => ({
              name: fileData.name,
              content: fileData.content,
              savedState: {
                minYOffset: fileData.minYOffset,
                minXOffset: fileData.minXOffset,
                scale: fileData.scale,
                color: fileData.color
              }
            }));
            // Simulate file input change with saved files
            const event = { target: { files: files } };
            await handleFiles(event);
            saveStatus.textContent = 'Previous state loaded!';
            saveStatus.style.color = '#007bff';
            setTimeout(() => {
              saveStatus.textContent = '';
            }, 2000);
          }
        }
      } catch (error) {
        console.error('Error loading state:', error);
        saveStatus.textContent = 'Error loading saved state';
        saveStatus.style.color = '#dc3545';
      }
      isLoading = false;
    }

    // Handle file processing
    async function handleFiles(event) {
      isLoading = true;
      canvas.innerHTML = '';
      individualControls.innerHTML = '';
      loadedFiles = [];
      attributeDisplay.style.display = 'none';
      selectedWrapper = null;
      selectedGroup = null;
      selectedSliders = {};
      const files = [...event.target.files];

      for (const [index, file] of files.entries()) {
        let text, name, savedState;
        if (file.content && file.savedState) {
          // Loaded from localStorage
          text = file.content;
          name = file.name;
          savedState = file.savedState;
        } else {
          // Real File object
          text = await file.text();
          name = file.name;
          savedState = file.savedState || {};
        }
        const wrapper = document.createElement('div');
        wrapper.className = 'svg-wrapper';
        wrapper.innerHTML = text;

        // Get the SVG element
        const svg = wrapper.querySelector('svg');
        if (!svg) continue;

        // Extract or set the original viewBox
        let originalViewBox = svg.getAttribute('viewBox');
        let [minX, minY, vbWidth, vbHeight] = [0, 0, 300, 300];
        if (originalViewBox) {
          [minX, minY, vbWidth, vbHeight] = originalViewBox.split(/\s+|,/).map(Number);
        } else {
          // If no viewBox, try to use width/height attributes
          vbWidth = parseFloat(svg.getAttribute('width')) || 300;
          vbHeight = parseFloat(svg.getAttribute('height')) || 300;
          svg.setAttribute('viewBox', `0 0 ${vbWidth} ${vbHeight}`);
        }
        // Store the base viewBox for this SVG
        svg._baseViewBox = { minX, minY, vbWidth, vbHeight };

        // Get saved state or use defaults (declare only once)
        const minYOffset = savedState.minYOffset !== undefined ? savedState.minYOffset : 0;
        const minXOffset = savedState.minXOffset !== undefined ? savedState.minXOffset : 0;
        const scale = savedState.scale !== undefined ? savedState.scale : 1;
        const color = savedState.color || getContrastingColor(index);

        // Set initial viewBox
        function setViewBox(minX, minY, scale) {
          const width = svg._baseViewBox.vbWidth / scale;
          const height = svg._baseViewBox.vbHeight / scale;
          svg.setAttribute('viewBox', `${minX} ${minY} ${width} ${height}`);
        }
        setViewBox(minX, minY, scale);

        // Ensure SVG is visible and properly sized
        svg.style.display = 'block';
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');

        canvas.appendChild(wrapper);

        const group = document.createElement('div');
        group.className = 'control-group';
        group.innerHTML = `<h4 style="cursor: pointer; user-select: none;">${name}</h4>`;

        // Create color controls
        const colorControls = document.createElement('div');
        colorControls.className = 'color-controls';
        const colorControl = document.createElement('div');
        colorControl.className = 'color-control';
        colorControl.innerHTML = `
          <label>Color:</label>
          <input type="color" id="color-${index}" value="${color}">
        `;
        const colorInput = colorControl.querySelector('input');
        const applyColor = (color) => {
          const allElements = svg.querySelectorAll('*');
          allElements.forEach(el => {
            if ([
              'path', 'circle', 'rect', 'ellipse', 'line', 'polyline', 'polygon', 'text'
            ].includes(el.tagName.toLowerCase())) {
              el.setAttribute('stroke', color);
              el.setAttribute('fill', color);
              if (!el.getAttribute('stroke-width')) {
                el.setAttribute('stroke-width', '1');
              }
            }
          });
        };
        applyColor(color);
        colorInput.addEventListener('input', () => {
          applyColor(colorInput.value);
          if (selectedWrapper === wrapper) {
            updateAttributeDisplay();
          }
        });
        colorControls.appendChild(colorControl);
        group.appendChild(colorControls);

        // Create controls for minY (top), minX (left), and scale
        // Store base values for inversion
        const controlConfigs = [
          { name: 'minY', label: 'top', min: -640, max: 640, value: minYOffset, step: 0.01, unit: 'px' },
          { name: 'minX', label: 'left', min: -480, max: 480, value: minXOffset, step: 0.01, unit: 'px' },
          { name: 'scale', label: 'scale', min: 0.01, max: 1, value: scale, step: 0.001, unit: '' }
        ];
        const sliders = {};
        controlConfigs.forEach(control => {
          const label = document.createElement('label');
          label.textContent = `${control.label}: `;
          const slider = document.createElement('input');
          slider.type = 'range';
          slider.min = control.min;
          slider.max = control.max;
          if (control.step) slider.step = control.step;
          // Set slider value directly from config (no inversion)
          let clampedValue = Math.max(control.min, Math.min(control.max, control.value));
          slider.value = String(clampedValue);
          const valueSpan = document.createElement('span');
          const displayValue = control.unit === 'px' ? Number(slider.value).toFixed(2) : Number(slider.value).toFixed(3);
          valueSpan.textContent = `${displayValue}${control.unit}`;
          label.appendChild(slider);
          label.appendChild(valueSpan);
          group.appendChild(label);
          group.appendChild(document.createElement('br'));
          slider.setAttribute('data-control', control.name);
          sliders[control.name] = slider;
          slider.addEventListener('input', () => {
            updateAllSliders();
          });
        });
        // After all sliders are created, update the UI once
        updateAllSliders();
        wrapper.sliders = sliders;
        wrapper.controlGroup = group;
        wrapper.fileName = name;
        wrapper.svg = svg;
        // Function to select this wrapper
        const selectWrapper = () => {
          if (selectedWrapper) {
            selectedWrapper.classList.remove('selected');
            selectedGroup.classList.remove('selected');
          }
          selectedWrapper = wrapper;
          selectedGroup = group;
          selectedSliders = sliders;
          wrapper.classList.add('selected');
          group.classList.add('selected');
          attributeDisplay.style.display = 'block'; // <-- Show attribute display when selected
          updateAttributeDisplay();
        };
        // Make the entire control group selectable on pointer down
        group.addEventListener('pointerdown', selectWrapper);
        individualControls.appendChild(group);
        // Store file data for saving
        loadedFiles.push({
          name: name,
          content: text,
          minYOffset: parseFloat(sliders.minY.value),
          minXOffset: parseFloat(sliders.minX.value),
          scale: parseFloat(sliders.scale.value),
          color: color
        });
        // --- FIX: Update SVG/UI once after all slider values are set ---
        function updateAllSliders() {
          // Invert minX/minY: slider value is offset, subtract from base
          const minXVal = svg._baseViewBox.minX - parseFloat(sliders.minX?.value ?? 0);
          const minYVal = svg._baseViewBox.minY - parseFloat(sliders.minY?.value ?? 0);
          const scaleVal = parseFloat(sliders.scale?.value ?? scale);
          setViewBox(minXVal, minYVal, scaleVal);
          // Update value display spans
          controlConfigs.forEach(control => {
            const slider = sliders[control.name];
            if (slider) {
              const valueSpan = slider.nextSibling;
              if (valueSpan && valueSpan.nodeType === Node.ELEMENT_NODE) {
                const displayValue = control.unit === 'px' ? Number(slider.value).toFixed(2) : Number(slider.value).toFixed(3);
                valueSpan.textContent = `${displayValue}${control.unit}`;
              }
            }
          });
          if (selectedWrapper === wrapper) {
            updateAttributeDisplay();
          }
        }
        updateAllSliders();
      }
      isLoading = false;
    }

    // Get contrasting color for different images
    function getContrastingColor(index) {
      const contrastingColors = [
        '#FF6B6B', // Red
        '#4ECDC4', // Teal
        '#1976D2', // Blue
        '#96CEB4', // Green
        '#FFEAA7', // Yellow
        '#DDA0DD', // Plum
        '#98D8C8', // Mint
        '#F7DC6F', // Gold
        '#BB8FCE', // Purple
        '#85C1E9'  // Light Blue
      ];
      return contrastingColors[index % contrastingColors.length];
    }

    fileInput.addEventListener('change', handleFiles);

    // Keyboard controls
    document.addEventListener('keydown', (event) => {
      if (!selectedWrapper || !selectedSliders) return;
      // Hide selected image on spacebar
      if (event.code === 'Space') {
        event.preventDefault();
        selectedWrapper.style.visibility = 'hidden';
        return;
      }
      // Move SVG up/down in stack with ArrowUp/ArrowDown
      if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
        event.preventDefault();
        const wrappers = Array.from(canvas.querySelectorAll('.svg-wrapper'));
        const groups = Array.from(individualControls.querySelectorAll('.control-group'));
        const index = wrappers.indexOf(selectedWrapper);
        if (index === -1) return;
        let newIndex = index;
        if (event.key === 'ArrowUp' && index > 0) {
          newIndex = index - 1;
        } else if (event.key === 'ArrowDown' && index < wrappers.length - 1) {
          newIndex = index + 1;
        } else {
          return;
        }
        // Move wrapper in canvas
        if (event.key === 'ArrowUp') {
          canvas.insertBefore(selectedWrapper, wrappers[newIndex]);
          individualControls.insertBefore(selectedGroup, groups[newIndex]);
        } else if (event.key === 'ArrowDown') {
          if (wrappers[newIndex].nextSibling) {
            canvas.insertBefore(selectedWrapper, wrappers[newIndex].nextSibling);
            individualControls.insertBefore(selectedGroup, groups[newIndex].nextSibling);
          } else {
            canvas.appendChild(selectedWrapper);
            individualControls.appendChild(selectedGroup);
          }
        }
        // Update loadedFiles order
        const movedFile = loadedFiles.splice(index, 1)[0];
        loadedFiles.splice(newIndex, 0, movedFile);
        // Reselect to keep highlight
        selectedWrapper.classList.add('selected');
        selectedGroup.classList.add('selected');
        autoSave();
        return;
      }
      const step = event.shiftKey ? 0.1 : 1;
      switch(event.key.toLowerCase()) {
        case 'w':
          event.preventDefault();
          const minYSlider = selectedSliders.minY;
          if (minYSlider) {
            // W should move image up (decrease slider value)
            const newValue = Math.max(parseFloat(minYSlider.min), parseFloat(minYSlider.value) - step);
            minYSlider.value = String(newValue);
            minYSlider.dispatchEvent(new Event('input'));
            autoSave();
          }
          break;
        case 's':
          event.preventDefault();
          if (selectedSliders.minY) {
            // S should move image down (increase slider value)
            const newValue = Math.min(parseFloat(selectedSliders.minY.max), parseFloat(selectedSliders.minY.value) + step);
            selectedSliders.minY.value = String(newValue);
            selectedSliders.minY.dispatchEvent(new Event('input'));
            autoSave();
          }
          break;
        case 'a':
          event.preventDefault();
          const minXSlider = selectedSliders.minX;
          if (minXSlider) {
            // A should move image left (decrease slider value)
            const newValue = Math.max(parseFloat(minXSlider.min), parseFloat(minXSlider.value) - step);
            minXSlider.value = String(newValue);
            minXSlider.dispatchEvent(new Event('input'));
            autoSave();
          }
          break;
        case 'd':
          event.preventDefault();
          if (selectedSliders.minX) {
            // D should move image right (increase slider value)
            const newValue = Math.min(parseFloat(selectedSliders.minX.max), parseFloat(selectedSliders.minX.value) + step);
            selectedSliders.minX.value = String(newValue);
            selectedSliders.minX.dispatchEvent(new Event('input'));
            autoSave();
          }
          break;
        case 'arrowleft':
          event.preventDefault();
          const scaleSlider = selectedSliders.scale;
          if (scaleSlider) {
            const stepSize = event.shiftKey ? 0.001 : 0.01;
            const newValue = Math.max(parseFloat(scaleSlider.min), parseFloat(scaleSlider.value) - stepSize);
            scaleSlider.value = String(newValue);
            scaleSlider.dispatchEvent(new Event('input'));
            autoSave();
          }
          break;
        case 'arrowright':
          event.preventDefault();
          if (selectedSliders.scale) {
            const stepSize = event.shiftKey ? 0.001 : 0.01;
            const newValue = Math.min(parseFloat(selectedSliders.scale.max), parseFloat(selectedSliders.scale.value) + stepSize);
            selectedSliders.scale.value = String(newValue);
            selectedSliders.scale.dispatchEvent(new Event('input'));
            autoSave();
          }
          break;
      }
    });

    // Show selected image again when spacebar is released
    document.addEventListener('keyup', (event) => {
      if (event.code === 'Space' && selectedWrapper) {
        selectedWrapper.style.visibility = 'visible';
      }
    });

    // Function to update attribute display
    function updateAttributeDisplay() {
      if (selectedWrapper && attributeDisplay.style.display !== 'none') {
        const svg = selectedWrapper.svg;
        // Invert minX/minY for display
        const minX = svg._baseViewBox.minX - parseFloat(selectedWrapper.sliders?.minX?.value || 0);
        const minY = svg._baseViewBox.minY - parseFloat(selectedWrapper.sliders?.minY?.value || 0);
        const scale = parseFloat(selectedWrapper.sliders?.scale?.value || 1);
        const width = svg._baseViewBox.vbWidth / scale;
        const height = svg._baseViewBox.vbHeight / scale;
        const color = svg.querySelector('*')?.getAttribute('stroke') || 'N/A';
        attributeContent.innerHTML = `
          <div class="attribute-item">
            <span class="attribute-label">File name:</span>
            <span class="attribute-value">${selectedWrapper.fileName || 'Unknown'}</span>
          </div>
          <div class="attribute-item">
            <span class="attribute-label">viewBox:</span>
            <span class="attribute-value">${minX} ${minY} ${width} ${height}</span>
          </div>
          <div class="attribute-item">
            <span class="attribute-label">Scale:</span>
            <span class="attribute-value">${scale.toFixed(3)}</span>
          </div>
          <div class="attribute-item">
            <span class="attribute-label">Color:</span>
            <span class="attribute-value">${color}</span>
          </div>
          <div class="attribute-item">
            <span class="attribute-label">SVG size:</span>
            <span class="attribute-value">width: ${svg.getAttribute('width')}px, height: ${svg.getAttribute('height')}px</span>
          </div>
        `;
      }
    }

    // Auto-save state when values change
    function autoSave() {
      if (isLoading) return;
      if (loadedFiles.length > 0) {
        // Update loadedFiles with current values
        const wrappers = canvas.querySelectorAll('.svg-wrapper');
        wrappers.forEach((wrapper, index) => {
          if (loadedFiles[index]) {
            const svg = wrapper.svg;
            const minYOffset = parseFloat(wrapper.sliders?.minY?.value ?? 0);
            const minXOffset = parseFloat(wrapper.sliders?.minX?.value ?? 0);
            const scale = parseFloat(wrapper.sliders?.scale?.value ?? 1);
            const colorInput = document.getElementById(`color-${index}`);
            const color = colorInput ? colorInput.value : loadedFiles[index].color;
            loadedFiles[index] = {
              ...loadedFiles[index],
              minYOffset,
              minXOffset,
              scale,
              color
            };
          }
        });
        // Save to localStorage (including canvas size)
        const state = {
          files: loadedFiles,
          canvasSize: {
            width: canvasWidthSlider.value,
            height: canvasHeightSlider.value
          }
        };
        localStorage.setItem('svgOverlayState', JSON.stringify(state));
        // Also save canvas size separately for legacy support
        localStorage.setItem('svgOverlayCanvasSize', JSON.stringify({ width: canvasWidthSlider.value, height: canvasHeightSlider.value }));
      }
    }

    // Add auto-save listeners
    document.addEventListener('input', autoSave);
    document.addEventListener('change', autoSave);

    // Load saved state on page load
    window.addEventListener('load', loadState);

    // Add Preview Modal logic
    function openPreviewModal() {
      const modal = document.getElementById('previewModal');
      const previewSVGs = document.getElementById('previewSVGs');
      previewSVGs.innerHTML = '';
      // Set preview size to always be 500px wide and auto height
      previewSVGs.style.width = '500px';
      // Dynamically set height to match canvas aspect ratio
      const canvasWidth = parseInt(canvas.style.width) || 640;
      const canvasHeight = parseInt(canvas.style.height) || 480;
      const aspectRatio = canvasHeight / canvasWidth;
      previewSVGs.style.height = (500 * aspectRatio) + 'px';
      // Stack all SVGs in order, absolutely positioned
      const wrappers = canvas.querySelectorAll('.svg-wrapper');
      let foundSVG = false;
      wrappers.forEach(wrapper => {
        // Try wrapper.svg, fallback to querySelector
        let svg = wrapper.svg || wrapper.querySelector('svg');
        if (svg) {
          const svgClone = svg.cloneNode(true);
          svgClone.style.position = 'absolute';
          svgClone.style.left = '0';
          svgClone.style.top = '0';
          svgClone.style.width = '100%';
          svgClone.style.height = '100%';
          svgClone.style.pointerEvents = 'none';
          svgClone.setAttribute('width', '100%');
          svgClone.setAttribute('height', '100%');
          previewSVGs.appendChild(svgClone);
          foundSVG = true;
        }
      });
      if (!foundSVG) {
        previewSVGs.innerHTML = '<div style="padding:2rem; text-align:center; color:#888;">No SVGs to preview.</div>';
      }
      modal.style.display = 'flex';
      document.addEventListener('keydown', handlePreviewModalKey);
    }
    function closePreviewModal() {
      const modal = document.getElementById('previewModal');
      modal.style.display = 'none';
      document.removeEventListener('keydown', handlePreviewModalKey);
    }
    function handlePreviewModalKey(e) {
      if (e.key === 'Escape') {
        closePreviewModal();
      }
    }

    // Add Combine SVG logic
    function combineSVGs() {
      const wrappers = canvas.querySelectorAll('.svg-wrapper');
      if (!wrappers.length) {
        alert('No SVGs to combine.');
        return;
      }
      // Use canvas size for initial output SVG, but we'll auto-fit the viewBox
      const canvasWidth = parseInt(canvasWidthSlider.value) || 640;
      const canvasHeight = parseInt(canvasHeightSlider.value) || 480;
      const svgNS = 'http://www.w3.org/2000/svg';
      const combinedSVG = document.createElementNS(svgNS, 'svg');
      combinedSVG.setAttribute('xmlns', svgNS);
      // For each SVG, create a <g> with the correct transform
      let allGroups = [];
      wrappers.forEach((wrapper, idx) => {
        let svg = wrapper.svg || wrapper.querySelector('svg');
        if (!svg) return;
        const g = document.createElementNS(svgNS, 'g');
        const base = svg._baseViewBox || { minX: 0, minY: 0, vbWidth: 300, vbHeight: 300 };
        const minXOffset = parseFloat(wrapper.sliders?.minX?.value || 0);
        const minYOffset = parseFloat(wrapper.sliders?.minY?.value || 0);
        const scaleVal = parseFloat(wrapper.sliders?.scale?.value || 1);
        // Calculate as in preview logic, but preserve aspect ratio
        const minX = base.minX - minXOffset;
        const minY = base.minY - minYOffset;
        const vbWidth = base.vbWidth;
        const vbHeight = base.vbHeight;
        const scaledWidth = vbWidth / scaleVal;
        const scaledHeight = vbHeight / scaleVal;
        const scale = Math.min(canvasWidth / scaledWidth, canvasHeight / scaledHeight);
        const offsetX = (canvasWidth - scaledWidth * scale) / 2;
        const offsetY = (canvasHeight - scaledHeight * scale) / 2;
        g.setAttribute('transform', `translate(${offsetX - minX * scale},${offsetY - minY * scale}) scale(${scale})`);
        Array.from(svg.childNodes).forEach(node => {
          g.appendChild(node.cloneNode(true));
        });
        combinedSVG.appendChild(g);
        allGroups.push(g);
      });
      // Set viewBox to match the overlay tool's canvas
      combinedSVG.removeAttribute('width');
      combinedSVG.removeAttribute('height');
      combinedSVG.setAttribute('viewBox', `0 0 ${canvasWidth} ${canvasHeight}`);
      combinedSVG.removeAttribute('style');
      // Serialize SVG
      const serializer = new XMLSerializer();
      const svgString = serializer.serializeToString(combinedSVG);
      const blob = new Blob([svgString], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'combined.svg';
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    }
  </script>
</body>
</html>
